package general.tutorial.java8.stream_api;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * Поток данных в потоковом API - канал передачи данных.
 * Поток данных представляет собой последовательность объектов.
 * Поток данных оперирует источником данных, например массивом
 * или коллекцией. В самом потоке данные не хранятся, а только
 * перемещаются и, возможно , фильтруются, сортируются или
 * обрабатываются иным образом в ходе этого процесса. Но, как
 * правило действие самого потока данных не видоизменяет их
 * источник. Например , сортировка данных в потоке не изменяет
 * их упорядочивание в источнике , а скорее приводит к созда-
 * нию нового потока данных, дающего отсортированный результат
 *
 * Под термином "поток данных" подразумеваются объекты, осно-
 * вывающиеся на одном из описываемых здесь типов потоков.
 *
 * java.util.stream
 *
 * В основании иерархии интерфейс BaseStream. В котором опре-
 * деляются основные возможности всех потоков данных.
 *
 * interface BaseStream<T,S extends BaseStream<T,S>>
 *    T - тип элементов в потоке
 *    S - тип потока данных, расширяющего интерфейс BaseStream
 *                         | | |
 * interface Stream<T> extends BaseStream
 *    T - тип элементов в потоке.
 *
 * Оконечная операция потребляет поток данных и дает конечный
 * результат. Если поток данных потреблен, он не может быть
 * использован повторно. Промежуточная операция производит по-
 * ток  данных и служит для создания конвейера для выполнения
 * последовательности действий . Кроме того, промежуточные
 * операции не выполняются немедленно.Напротив, указанное дей-
 * ствие происходит в том случае, когда оконечная операция
 * выполняется в новом потоке данных, созданном промежуточной
 * операцией.Такой механизм называется отлаженным поведением,
 * а промежуточные операции - отложенными.
 *    Еще одна особенность потоков данных состоит в том, что
 * одни промежуточные операции выполняются без сохранения
 * состояния , а другие с сохранением состояния. В операции
 * без сохранения состояния каждый элемент обрабатывается
 * независимо от остальных.А в операции с сохранением состоя-
 * ния обработка элемента может зависеть от особенностей ос-
 * тальных элементов . Например, сохранение данных является
 * операцией с сохранением состояния, поскольку упорядочение
 * элемента зависит от значений других элементов. Следова-
 * тельно , метод sorted() выполняется с сохранением состояния.
 * Отличие операция с сохранением состояния от операция без
 * созранения состояния особенно важно для параллельной обработки
 * потоков данных, поскольку операцию с сохранением состояния,
 * возможно, придется выполнить не за один, а за несколько
 * проходов.
 *
 */


public class StreamApiDemo {

    public static void main(String args[]){

        ArrayList<Integer> myList = new ArrayList<>();
        myList.add(7);
        myList.add(42);
        myList.add(35);
        myList.add(95);
        myList.add(1);

        System.out.println("Исходный список: " + myList);

        // получить поток элементов списочного массива
        Stream<Integer> myStream = myList.stream();

        // получить мин. и макс. знач.
        Optional<Integer> minVal = myStream.min(Integer::compare);
        minVal.ifPresent(integer -> System.out.println("Мин. значение : " + integer));

        myStream = myList.stream();
        Optional<Integer> maxVal = myStream.max(Integer::compare);
        maxVal.ifPresent(integer -> System.out.println("Макс. значение : " + integer));

        // отсортироватьт поток данных , вызвав метод sorted()
        Stream<Integer> sorteStream = myList.stream().sorted();

        // отобразить остортированный поток данных, вызвав мтод forEach()
        System.out.print("Отсортированный поток данных: ");
        sorteStream.forEach((n)-> System.out.print(n + " "));
        System.out.println();

        // вывести только нечетные целочисленные значения,
        // вызвав метод filter()
        Stream<Integer> oddVals =
                myList.stream().sorted().filter((n) -> (n % 2) == 1);
        System.out.print("Нечетные значения: ");
        oddVals.forEach((n) -> System.out.print(n + " "));
        System.out.println();

        // вывести только те нечетные целочисленные значения,
        // которые больше 5. Обратите внимание на конвейеризацию
        // обеих операция фильтрации
        oddVals = myList.stream().filter((n) -> (n % 2) == 1)
                                 .filter((n) -> n > 5);
        System.out.print("Нечетные значения больше 5: ");
        oddVals.forEach((n) -> System.out.print(n + " "));
        System.out.println();

        /**
         * Рассмотрим подробнее методы min() и max() из примера выше.
         * Оба методы выполняют оконечные операции и возвращают результат,
         * исходя их элементов в потоке данных. По терминологии потокового API
         * эти методы представляют собой операции сведения, поскольку
         * каждый их них сводит поток данных к единственном значению
         * (в данном случае - максимальному и минимальному соответсвенно).
         * В потоком API такие операции сведения называются особыми,
         * поскольку они выполняют особую функцию.В методе reduce()
         * можно возвратить значение из потока данных по любому произвольному
         * критерию. По определению все операции сведения являются оконечными.
         *
         * Optional<T> reduce(BinaryOperator<T> накопитель)
         * T reduce(T значение_идентичности, BinaryOperator<T> накопитель)
         *
         * В первой форме возвращается объект типа Optional, содержащий
         * полученный результат , а во второй форме - объект типа T, т.е типа
         * элемента из потока данных. В обеих формах указанный накопитель
         * обозначает функцию , оперирующию двумя значениями и получающую результат.
         * Во второй форме значение_идентичности и любой элемент из потока данных,
         * дает в итоге тот же самый элемент без изменения.Так, если выполняется
         * операция сложения , то значение идентичности равно нулю , поскольку
         * 0 + х = х. А если выполняется операция умножения, то значение идентичности
         * равно 1, поскольку 1 * х = х. Со значения идентичности начинается выражение.
         *
         */

        // Продемонистрировать применение метода reduce()

        // Два способа получения результата перемножения целочисленных
        // элементов списка myList с помощью метода reduce()
        Optional<Integer> productObj = myList.stream().reduce((a,b) -> a*b);
        productObj.ifPresent((integer) ->
                System.out.println("Произведение в виде объекта типа Optional: "
                        + integer));
        int product = myList.stream().reduce(0, (a,b) -> a+b);
        System.out.println(
                "Произведение в виде значения типа int: " + product);

        /**
         * По отношению к методу reduce() параметр значение1 метода apply()
         * будет содержать предыдущий результат, тогда как параметр значение2 -
         * следующий элемент. При первом вызове данного метода памаретр значени2
         * будет содержать значение идентичности или первый элемент в записимости от
         * применяемого варианта метода reduce().
         */


        /**
         * Параллельные потоки данных.
         *
         * Например , первая операция свидения , выполняемая методом reduce()
         * в предыдущей программе , может быть распараллелена, если вызов
         * метода stream() заменить на вызов метода parallelStream().
         *
         * Optional<Integer> productObj = myList.parallelStream().reduce((a,b) -> a*b);
         *
         *    Как правило , любая операция в параллельном потоке данных должна выполняться
         * без сохраненя состояния. Она должна быть также ассоциативной и без
         * вмешательства. Этим гарантируется, что результаты выполнентия операций в
         * параллельном потоке данных остаются такими же как и результаты выполнения
         * аналогичных операций в последовальном потоке данных.
         *    Для применения параллельных потоков данных особенно полезной может оказаться
         * приведенный ниже вариант метода reduce(). Этот вариант позволяет указать
         * порядок объеденения частичных результатов.
         *
         * <U> U reduce(U значение_идентичности , BiFunction<U, ? super T, U>
         *              накопитель ,BinaryOperator<U> объединитель)
         *
         * int parallelProduct = myList.parallelStream().reduce(1, (a,b) -> a*b,(a,b) -> a*b);
         */

        // Продемонстрировать применение объединяющего
        // варианта метода reduce()

        ArrayList<Double> myListDouble = new ArrayList<>();

        myListDouble.add(7.0);
        myListDouble.add(18.0);
        myListDouble.add(10.0);
        myListDouble.add(24.0);
        myListDouble.add(17.0);
        myListDouble.add(5.0);

        double productOfSqrRoots = myListDouble.parallelStream().reduce(
                1.0,
                (a,b) -> a * Math.sqrt(b),
                (a,b) -> a*b
        );
        System.out.println("Произведение квадратных корней: " + productOfSqrRoots);

        /**
         * Организуя параллельное выполнение в потоке данных, следует также
         * принимать во внимание порядок следованитя элементов. Потоки данныъ могут
         * бытть как упорядоченными, так и неупорядоченными. Если источник данных
         * упорядочен, то, как правило, упорядочен и поток данных.
         */



    }
}
