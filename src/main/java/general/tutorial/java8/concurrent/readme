                                    Прерывание потоков исполнения.

Для запроса на прерывание потока исполнения может быть вызван метод interrupt(). Когда метод вызывается для потока
исполнения, устанавливается состояние прерывания данного потока. Это признак типа boolean, имеющийся у каждого потока
исполнения. Статический метод Thread.currentThread(), получающий текущий поток исполнения и вызывающий далее метод
isInterrupted(). Но если поток исполнения заблокирован , то проверить состояние его прерывания нельзя . И здесь на
помощь приходит исключение InterruptedException. Когда метод interrupt() вызывается у заблокированного потока , например
в результате вызова sleep() или wait() , блокирующий вызов прерывается исключением InterruptedException.

void interrupt() - Посылает потоку исполнения запрос на прерывание. Признак состояния прерывания потока исполнения
                   устанавливается в положение true. Если поток в данный момент блокирован вызовом метода sleep(),
                   генерируется исключение типа InterruptedException.

static boolean interrupted() - Проверяет, был ли прерван текущий поток исполнения. Имейте ввиду , что его вызов имеет
                               побочный эффект: признак состояния прерывания текущего потока исполнения устанавливается
                               равным логическому значению false.

boolean isInterrupted() - Проверяет бы ли прерван поток исполнения.

static Thread currentThread() - Возвращает обхект Thread предавляющий текущий поток исполнения.


                                        Состояния потоков исполнения.

- новый
- исполняемый
- блокированный
- ожидающий
- временно ожидающий
- завершенный

Чтобы определить текущее состояние потока исполнения, достаточно вызвать метод getState().


Исполняемый поток может выполняться или не выполняться в данный момент, поскольку от операционной системы зависит,
будет ли выделено потоку время на исполнение. Если поток запущен он не обязательно продолжает исполняться. Выбирая
следующий поток исполнения, операционная система принимает во внимание приоритеты потоков исполнения.
Во всех современных настольных и серверных операционных системах применяется приоритетное(вытесняющее) планирование.
    На машинах с несколькими процессорами каждый процессор может исполнять поток, что позволяет иметь несколько потоков,
работающих одновременно.

- void join() - Ожидает завершения указанного потока.
- void join(long millis) - Ожидает завершения указанного потока исполнения или истечения заданного периода времени.
- Thread.State.getState() - Получает состояние данного потока исполнения . NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING
- void stop() - Останавливает поток ( Не рекомендуется к использованию)
- void suspend() - Временно приостанавливает поток исполнения . (Не рекомендован)
- resume() - возобновляет (Не рекомендован)



                                         Приоритеты потоков исполнения.

В Java у потока исполнения есть свой приоритет. По умолчанию - поток исполнения наследует приоритет того потока, который
его создал. Повысить или понизить приоритет любого потока исполнения можно, вызвав метод setPriority(). А установить
приоритет потока можно указав любое значение в пределах от 1 до 10. Обычному приоритету соответствует значение
NORM_PRIORITY , равное 5. Но приоритеты потоков сильно зависят от системы.Приоритеты потоков Java привязываются к уровням
приориттов этой платформы.

Например в Windows предусмотрено семь уровней приоритетов. В виртуальной машине Oracle для Linux приоритеты потоков
исполнения вообще игнорируются. Все потоки исполнения имеют одинаковый приоритет.Не рекомендуется писать программы таким
образом , чтобы их правильное функционирование зависело от уровней приоритетов.


                                            Потоковые демоны.

Превратить поток исполнения в потоковый демон можно, сделав следующий вызов: t.setDaemon(true);
    Демон - это лишь поток у которого цель - служить другим потокам. Например - таймер или поток который очищает уста-
ревшие записи в кеше. Когда остаются только потоковые демоны, виртуальная машина завершает работу. Потоковый демон
вообще не должен обращаться к такому постоянному ресурсу , как файл или база данных, поскольку он может быть прерван
в любой момент , даже посередине операции.
- void setDaemon(boolean isDaemon) - помечает данный поток как демон или пользовательский поток. Этот метод должен
                                     вызываться перед запуском потока.

                                        Обработчики необрабатываемых исключений.

Исключение передается обработчику необрабатываемых исключений. Такой обработчик должен относиться к классу, реализу-
ющему интерфейс Thread.UncaughtExceptionHandler. У этого интерфейса имеется единственный метод:
- void uncaughtException(Thread t, Throwable e)
Этот обработчик можно установить в любом потоку исполнения с помощтю метода setUncaughtExceptionHandler().